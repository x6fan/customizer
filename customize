#! /usr/bin/env python
# Game Customizer

import os
import sys
import hashlib
import json

# Module root directory
root = os.path.abspath(os.path.dirname(__file__))

# Load JSON data located at path
def load_json(path):
    with open(path) as data:
        return json.load(data)

# Loads a JSON database of games supported by the customizer
def load_supported_games():
    return load_json(os.path.join(root, 'games.json'))

# Games supported by this customization tool
supported_games = load_supported_games()

# Loads customization data for the specified game
def load_game_data_for(game):
    return load_json(os.path.join(root, 'games', game + '.json'))

# Hashes a readable stream, uses SHA-1 by default
def hash(io, function = hashlib.sha1, block_size = 64 * 1024):
    hash = function()
    blocks = iter(lambda: io.read(block_size), b'')

    for block in blocks:
        hash.update(block)

    return hash.hexdigest()

# Returns the game's symbol if its customization is supported, None otherwise
def detect(game_image):
    sha1 = hash(game_image)

    for game, metadata in supported_games.items():
        if metadata['sha1'] == sha1:
            return game

    return None

# Converts value to size bytes and writes them at offset
def patch(io, offset, value, size, endianness):
    data = value.to_bytes(size, byteorder = endianness)
    io.seek(offset)
    io.write(data)

# Merges values from common and specific data types with the given leaf object
def merge_type_values(leaf_object, data_types):
    if 'type' in leaf_object:
        leaf_type = leaf_object['type']
        specific_type = data_types[leaf_type]
        leaf_object = { **specific_type, **leaf_object }

    # The common type is special: it gets merged to all leaf objects if present
    if 'common' in data_types:
        common_type = data_types['common']
        leaf_object = { **common_type, **leaf_object }

    return leaf_object

# Maps a symbolic value to the actual value according to the "values" property
def map_symbolic_values(leaf_object, key_or_value):
    if 'values' in leaf_object:
        return leaf_object['values'][key_or_value]
    else:
        return key_or_value

# Applies the custom value according to the given customization parameters
def apply_customization(game_image, key_or_value, parameters, data_types):
    parameters = merge_type_values(parameters, data_types)
    value = map_symbolic_values(parameters, key_or_value)

    patch(
        game_image,
        parameters['offset'],
        value,
        parameters['size'],
        parameters['endianness']
    )

# Determines whether the given value is a customization parameters dictionary
def is_customization_parameters(value):
    return (type(value) is dict) and ('offset' in value) or ('type' in value)

# Customize game image given user's preferences and available customizations
def customize(game_image, customizations, customization_data, data_types, stack = [], callback = None):
    for key, user_value in customizations.items():
        data_value = customization_data[key]

        stack.append(key)

        if is_customization_parameters(data_value):
            # We reached a leaf of the tree
            # user_value is the user's custom value
            # data_value is customization parameters

            if callable(callback):
                callback(stack, user_value)

            apply_customization(game_image, user_value, data_value, data_types)

        else:
            # We can still go deeper
            # user_value and data_value are objects
            assert type(user_value) is dict
            assert type(data_value) is dict

            customize(
                game_image,
                user_value,
                data_value,
                data_types,
                stack = stack,
                callback = callback
            )

        stack.pop()

def trace_customizations(stack, value):
    print('%s = %s' % ('.'.join(stack), value))

def main(game_image, user_customizations):
    detected_game = detect(game_image)

    if detected_game:
        print('Detected game: %s' % detected_game)
    else:
        print('Unknown game')
        return

    game_data = load_game_data_for(detected_game)

    customize(
        game_image,
        user_customizations,
        game_data['customizations'],
        game_data['data_types'],
        callback = trace_customizations
    )

if __name__ == '__main__':
    game_image_path = os.path.abspath(sys.argv[1])

    with open(game_image_path, 'r+b', buffering = 0) as game_image:
        main(game_image, json.load(sys.stdin))
