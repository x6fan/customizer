#! /usr/bin/env python
# Game Customizer

import os
import sys
import hashlib
import json

# Module root directory
root = os.path.abspath(os.path.dirname(__file__))

# Load JSON data located at path
def load_json(path):
    with open(path) as data:
        return json.load(data)

# Loads a JSON database of games supported by the customizer
def load_supported_games():
    return load_json(os.path.join(root, 'games.json'))

# Games supported by this customization tool
supported_games = load_supported_games()

# Loads customization data for the specified game
def load_game_data_for(game):
    return load_json(os.path.join(root, 'games', game + '.json'))

# Hashes a readable stream, uses SHA-1 by default
def hash(io, function = hashlib.sha1, block_size = 64 * 1024):
    hash = function()
    blocks = iter(lambda: io.read(block_size), b'')

    for block in blocks:
        hash.update(block)

    return hash.hexdigest()

# Returns the game's symbol if its customization is supported, None otherwise
def detect(game_image):
    sha1 = hash(game_image)

    for game, metadata in supported_games.items():
        if metadata['sha1'] == sha1:
            return game

    return None

# Converts value to size bytes and writes them at offset
def patch(io, offset, value, size, endianness):
    data = value.to_bytes(size, byteorder = endianness)
    io.seek(offset)
    io.write(data)

# Applies the custom value according to the given customization parameters
def apply_customization(game_image, value, parameters):
    patch(
        game_image,
        parameters['offset'],
        value,
        parameters['size'],
        parameters['endianness']
    )

# Determines whether the given value is a customization parameters dictionary
def is_customization_parameters(value):
    return (type(value) is dict) and ('offset' in value) and ('size' in value) and ('endianness' in value)

# Customize game image given user's preferences and available customizations
def customize(game_image, customizations, customization_data, level = 0, callback = None):
    for key, user_value in customizations.items():
        assert key in customization_data
        data_value = customization_data[key]

        if is_customization_parameters(data_value):
            # We reached a leaf of the tree
            # user_value is the user's custom value
            # data_value is customization parameters

            if callable(callback):
                callback(
                    'customize-leaf',
                    { 'level': level, 'key': key, 'value': user_value }
                )

            if 'values' in data_value:
                user_value = data_value['values'][user_value]

            apply_customization(game_image, user_value, data_value)

        else:
            # We can still go deeper
            # user_value and data_value are objects
            assert type(user_value) is dict
            assert type(data_value) is dict

            if callable(callback):
                callback('customize', { 'level': level, 'key': key })

            customize(
                game_image,
                user_value,
                data_value,
                level = level + 1,
                callback = callback
            )

def trace_customizations(context, data):
    string = None

    if context == 'customize':
        level = data['level']
        key = data['key']

        string = '%s%s' % ('\t' * level, key)

    elif context == 'customize-leaf':
        level = data['level']
        key = data['key']
        value = data['value']

        string = '%s%s = %s' % ('\t' * level, key, value)

    print(string)

def main(game_image, user_customizations):
    detected_game = detect(game_image)

    if detected_game:
        print('Detected game: %s' % detected_game)
    else:
        print('Unknown game')
        return

    game_data = load_game_data_for(detected_game)

    customize(
        game_image,
        user_customizations,
        game_data['customizations'],
        callback = trace_customizations
    )

if __name__ == '__main__':
    game_image_path = os.path.abspath(sys.argv[1])

    with open(game_image_path, 'r+b', buffering = 0) as game_image:
        main(game_image, json.load(sys.stdin))
